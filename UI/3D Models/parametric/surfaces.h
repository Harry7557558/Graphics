// parametric surface equations for generating objects in run-time
// most surfaces are designed from aesthetic view


#ifndef __INC_GEOMETRY_H
#include "numerical/geometry.h"
#endif

// Parametric surface class
#include <functional>
#include <vector>
template<typename Fun>
class ParametricSurface {
public:
	double u0, u1, v0, v1;  // parameter intervals
	int uD, vD;  // recommended discretization splits
	const Fun P;  // equation, vec3 P(u,v)
	uint32_t id;  // optional
	ParametricSurface(Fun P,
		double u0 = NAN, double u1 = NAN, double v0 = NAN, double v1 = NAN, int uD = 0, int vD = 0,
		const char* name = nullptr)
		:u0(u0), u1(u1), v0(v0), v1(v1), uD(uD), vD(vD), P(P) {
		id = hash(name);
	}
	static uint32_t hash(const char* s) {
		uint32_t h = 0;
		while (*s) h = 1664525u * h + 1013904223u * *(s++);
		return h;
	}

	// triangulation
	int param2points(std::vector<vec3> &p,
		vec3 translate = vec3(0.), double scale = 1.) const {
		p.reserve(p.size() + (uD + 1)*(vD + 1));
		double du = (u1 - u0) / uD, dv = (v1 - v0) / vD;
		for (int ui = 0; ui <= uD; ui++) {
			for (int vi = 0; vi <= vD; vi++) {
				double u = u0 + ui * du, v = v0 + vi * dv;
				p.push_back(scale * P(u, v) + translate);
			}
		}
		return (uD + 1)*(vD + 1);
	}
	int param2trigs(std::vector<triangle> &p,
		vec3 translate = vec3(0.), double scale = 1.) const {
		p.reserve(p.size() + 2 * uD*vD);
		auto F = [&](double u, double v) {
			return scale * P(u, v) + translate;
		};
		double du = (u1 - u0) / uD, dv = (v1 - v0) / vD;
		for (int ui = 0; ui < uD; ui++) {
			for (int vi = 0; vi < vD; vi++) {
				double u = u0 + ui * du, v = v0 + vi * dv;
				vec3 p00 = F(u, v);
				vec3 p01 = F(u, v + dv);
				vec3 p10 = F(u + du, v);
				vec3 p11 = F(u + du, v + dv);
#if 1
				if ((p01 - p10).sqr() < (p00 - p11).sqr()) {
					p.push_back(triangle{ p10, p00, p01 });
					p.push_back(triangle{ p01, p11, p10 });
				}
				else {
					p.push_back(triangle{ p11, p10, p00 });
					p.push_back(triangle{ p00, p01, p11 });
				}
#else
				p.push_back(triangle{ p10, p00, p01 });
				p.push_back(triangle{ p01, p11, p10 });
#endif
			}
		}
		return 2 * uD * vD;
	}

	// take a point list generated by `param2points` and generate triangles
	int points2trigs(const vec3* P, std::vector<triangle> &T) const {
		T.reserve(T.size() + 2 * uD*vD);
		for (int ui = 0; ui < uD; ui++) {
			for (int vi = 0; vi < vD; vi++) {
				vec3 p00 = P[ui*(vD + 1) + vi];
				vec3 p01 = P[ui*(vD + 1) + (vi + 1)];
				vec3 p10 = P[(ui + 1)*(vD + 1) + vi];
				vec3 p11 = P[(ui + 1)*(vD + 1) + (vi + 1)];
				if ((p01 - p10).sqr() < (p00 - p11).sqr()) {
					T.push_back(triangle{ p10, p00, p01 });
					T.push_back(triangle{ p01, p11, p10 });
				}
				else {
					T.push_back(triangle{ p11, p10, p00 });
					T.push_back(triangle{ p00, p01, p11 });
				}
			}
		}
		return 2 * uD * vD;
	}
};
typedef ParametricSurface<vec3(*)(double, double)> ParametricSurfaceP;
typedef ParametricSurface<std::function<vec3(double, double)>> ParametricSurfaceL;




// function templates

namespace ParametricSurfaceTemplates {

	vec3 Archimedean_snail(double u, double v,
		double vert, double offset, double layer_n) {

		/* 0 < u < 2π, 0 < v < 1
		   For a right-handed snail, all of the following are positive:
			- vert: height/sharpness, vertice=(0,0,vert)
			- offset: offset from z-axis, 1.0 for a "standard" snail
			- layer_n: number of layers of the snail
		*/

		return (1. - v)*vec3(
			(cos(u) + offset)*cossin(2.*PI*layer_n*v),
			sin(u)) + vec3(0, 0, vert*v);
	};

	vec3 Logarithmic_snail(double u, double v,
		double exp_k, double vert, double offset, double layer_n) {

		/* 0 < u < 2π, v0 < v < v1
			- exp_k: r=exp(k/2π*θ), positive
			- vert: z_vertice = exp(exp_k)*vert
			- offset: offset from z-axis, 1.0 for a "standard" snail
			- layer_n: number of layers of the snail when -1<v<1
			- v0, v1: custom parameters, v0 can be -INFINITY
		*/

		return exp(exp_k*v) * vec3(
			cossin(PI*layer_n*v)*(offset + cos(u)),
			vert*(exp(exp_k - exp_k * v) - 2.) + sin(u));

		// right-handed version
		return exp(exp_k*v) * vec3(
			sincos(PI*layer_n*v)*(offset + cos(u)),
			vert*(exp(exp_k - exp_k * v) - 2.) - sin(u));
	};


}



const std::vector<ParametricSurfaceL> ParamSurfaces({

	/*[0]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.2, 1.0, 3.0);
	}, 0., 2.*PI, 0., 1., 40, 120, "land snail"),

	/*[1]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 2.2, 1.0, 4.5);
	}, 0., 2.*PI, 0., 1., 40, 120, "river snail"),

	/*[2]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.1, 0.5, 2.0);
	}, 0., 2.*PI, 0., 1., 40, 120, "field snail"),

	/*[3]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.8, 0.2, 2.4);
	}, 0., 2.*PI, 0., 1., 40, 120, "pond snail"),

	/*[4]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 3.5, 0.2, 8.0);
	}, 0., 2.*PI, 0., 1., 40, 120, "cone snail"),

	/*[5]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.45, 1.7, 0.35, 2.1);
	}, 0., 2.*PI, -7., 1., 40, 120, "pot snail"),

	/*[6]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.65, 0.55, 0.86, 1.0);
	}, 0., 2.*PI, -6., 1., 40, 160, "moon snail"),

	/*[7]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.7, 0.0, 1.05, 1.0);
	}, 0., 2.*PI, -5., 1., 40, 160, "snail (in)"),

	/*[8]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.9, 0.0, 2.0, 1.0);
	}, 0., 2.*PI, -6., -1., 40, 160, "snail (out)"),

	/*[9]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 1.8, 1.2, 2.7, 1.0);
	}, 0., 2.*PI, -3., 1., 40, 160, "snail (outer)"),

	/*[10]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			cossin(3.*PI*v)*(2.0 + cos(u)) + 0.05*cossin(60.*PI*v),
			sin(u) + 0.05*sin(10.*u))*exp(v);
	}, 0., 2.*PI, -4., 1., 80, 1000, "textured snail 1"),

	/*[11]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			sincos(3.*PI*v)*(1. + cos(u)) + 0.1*cossin(-10.*u),
			4. - (v + 4.) - 0.9*sin(u))*exp(0.8*v);
	}, 0., 2.*PI, -4., 1., 100, 800, "textured snail 2"),

	/*[12]*/ ParametricSurfaceL([](double u, double v) {
		vec3 p = vec3(
			cossin(PI*3.*v)*(1. + cos(u)) + 0.1*cossin(40.*PI*v),
			(exp(1. - v) - 2.) + sin(u));
		p += 0.06*vec3(sin(10.*p.x)*sin(10.*p.y)*cos(10.*p.z));
		return p * exp(v);
	}, 0., 2.*PI, -3., 1., 100, 1600, "textured snail 3"),

	/*[13]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			sincos(3.*PI*v)*(0.9 + cos(u)) + 0.05*cossin(40.*PI*v)*cos(10.*u)*(1. + cos(u)),
			(exp(1.5 - 0.9*v) - 3.) - 1.1*sin(u))*exp(0.9*v);
	}, 0., 2.*PI, -4., 1., 100, 800, "textured snail 4"),

	/*[14]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(sincos(3.*PI*v)*(1. + cos(u)), -1.1*sin(u))
			*exp(0.8*v)*(.5*cos(20.*PI*v) + .9)*(.05*cos(10.*u) + 1.)
			+ vec3(0, 0, 5. - 4.*exp(v));
	}, 0., 2.*PI, -4., 1., 80, 1000, "textured snail #1"),

	/*[15]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			(1 - .05*exp(sin(u)))*(cossin(3.*PI*v)*(2.0 + cos(u)) + 0.05*cossin(60.*PI*v)),
			-exp(1. - .5*v) + sin(u) + 0.1*sin(10.*u)*sin(20.*PI*v)*exp(v))*exp(v)
			+ vec3(0, 0, 4.);
	}, 0., 2.*PI, -4., 1., 100, 1000, "textured snail #2"),

	/*[16]*/ ParametricSurfaceL([](double u, double v) {
		return exp(v) * vec3(
			cossin(PI*3.*v)*(1. + cos(u)),
			(exp(1. - v) - 2.) + exp(v)*sin(u));
	}, 0., 2.*PI, -3., 1., 60, 300, "melon snail"),

	/*[17]*/ ParametricSurfaceL([](double u, double v) {
		vec3 p = exp(v) * vec3(
			cossin(PI*3.*v)*(1. + cos(u)),
			.55*(exp(1. - v) - 2.) + sin(u));
		return p + vec3(0, 0, 3. - exp(-.55*p.z));
	}, 0., 2.*PI, -3., 1., 60, 300, "bailer snail"),

	/*[18]*/ ParametricSurfaceL([](double u, double v) {
		vec2 cr(cos(u) + .2*sin(u)*sin(u), -1.3*sin(u) + cos(u)*cos(u));
		return exp(.4*v)*vec3((.5 + .8*cr.x + .3*cr.y)*sincos(PI*v),
			2.8*(exp(-.4*v) - 1.) + cr.y - .3*cr.x);
	}, 0., 2.*PI, -9., 1., 60, 300, "wonder shell"),

	/*[19]*/ ParametricSurfaceL([](double u, double v) {
		vec2 cr = vec2(0.510504, -1.134042)
			+ mat2(0.598892, -0.609437, 0.541083, -3.788403) * cossin(u)
			+ mat2(-0.120320, -0.350955, 0.732847, 0.994199) * cossin(2.*u)
			+ mat2(-0.078252, -0.022159, -0.453444, 0.324241) * cossin(3.*u);
		/*vec2 cr = vec2(0.511682, -0.980377)
			+ mat2(0.598368, -0.607140, 0.472696, -3.488780) * cossin(u)
			+ mat2(-0.122442, -0.351977, 0.455953, 0.860854) * cossin(2.*u)
			+ mat2(-0.076784, -0.024001, -0.261828, 0.083962) * cossin(3.*u);*/
		cr.y = 5.*tanh(.2*cr.y);  // too sharp
		cr.y = .2*log(exp(5.*cr.y) + exp(5.*-3.6));  // clamp at y=-3.6 like that of natural snail
		return exp(.3*v)*vec3(cr.x*sincos(PI*v),
			3.*(exp(-.3*v) - 1.) + cr.y);
	}, 0., 2.*PI, -9., 1., 60, 300, "pear shell"),

});





// functions that may be useful for normalizing test shapes

// calculate the center of mass of an object
// assume the object is a surface with uniform surface density
vec3 calcCOM_shell(const triangle* T, int N) {
	double A = 0; vec3 C(0.);
	for (int i = 0; i < N; i++) {
		double dA = T[i].area();
		vec3 dC = (1. / 3.)*(T[i].A + T[i].B + T[i].C);
		A += dA, C += dA * dC;
	}
	return C * (1. / A);
}
// calculate the axis-aligned bounding box, return the center
vec3 calcAABB(const triangle* T, int N, vec3* rad = 0) {
	const vec3* P = (vec3*)T; N *= 3;
	vec3 Min(INFINITY), Max(-INFINITY);
	for (int i = 0; i < N; i++) {
		Max = pMax(Max, P[i]);
		Min = pMin(Min, P[i]);
	}
	if (rad) *rad = .5*(Max - Min);
	return .5*(Max + Min);
}

// translate the object so its center is the origin
void translateToCOM_shell(triangle* T, int N) {
	vec3 D = -calcCOM_shell(T, N);
	for (int i = 0; i < N; i++) T[i].translate(D);
}
void translateToAABBCenter(triangle* T, int N) {
	vec3 D = -calcAABB(T, N);
	for (int i = 0; i < N; i++) T[i].translate(D);
}


// calculate the maximum "radius" of the object from the origin
double calcMaxRadius(const triangle* T, int N) {
	const vec3* P = (vec3*)T; N *= 3;
	double maxR = 0.;
	for (int i = 0; i < N; i++) {
		double r = P[i].sqr();
		if (r > maxR) maxR = r;
	}
	return sqrt(maxR);
}
// calculate the radius of gyration of an object, assuming uniform surface density
double calcGyrationRadius_shell(const triangle* T, int N) {
	// not sure if I calculated this correctly
	double A = 0.; mat3 I(0.);
	for (int i = 0; i < N; i++) {
		vec3 a = T[i].A, b = T[i].B, c = T[i].C;
		double dA = 0.5*length(cross(b - a, c - a));
		A += dA;
		I += dA / 6. *(mat3(dot(a, a) + dot(b, b) + dot(c, c) + dot(a, b) + dot(a, c) + dot(b, c)) -
			(tensor(a, a) + tensor(b, b) + tensor(c, c) + 0.5*(tensor(a, b) + tensor(a, c) + tensor(b, a) + tensor(b, c) + tensor(c, a) + tensor(c, b))));
	}
	return sqrt(cbrt(determinant(I)) / A);
}
// calculate sqrt[∫(r²dS)/∫(dS)], assume the object is a surface
double calcRotationRadius_shell(const triangle* T, int N) {
	double I = 0., S = 0.;
	for (int i = 0; i < N; i++) {
		vec3 a = T[i].A, b = T[i].B, c = T[i].C;
		double dS = 0.5*length(cross(b - a, c - a));
		double dI = (1. / 12.)*(a.sqr() + b.sqr() + c.sqr() + dot(a, b) + dot(a, c) + dot(b, c));
		S += dS, I += dI * dS;
	}
	return sqrt(I / S);
}


// scale the object to a fixed size
// visually, scaleGyrationRadiusTo works best but it is the slowest
void scaleMaxRadiusTo(triangle* T, int N, double r) {
	double s = r / calcMaxRadius(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}
void scaleGyrationRadiusTo_shell(triangle* T, int N, double r) {
	double s = r / calcGyrationRadius_shell(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}
void scaleRotationRadiusTo_shell(triangle* T, int N, double r) {
	double s = r / calcRotationRadius_shell(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}

